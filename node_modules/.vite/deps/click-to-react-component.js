import {
  require_react_dom
} from "./chunk-E3OHECZP.js";
import {
  require_react
} from "./chunk-WQMOH32Y.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/point-in-polygon/flat.js
var require_flat = __commonJS({
  "node_modules/point-in-polygon/flat.js"(exports, module) {
    module.exports = function pointInPolygonFlat(point, vs, start, end) {
      var x = point[0], y = point[1];
      var inside = false;
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = vs.length;
      var len = (end - start) / 2;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
        var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect)
          inside = !inside;
      }
      return inside;
    };
  }
});

// node_modules/point-in-polygon/nested.js
var require_nested = __commonJS({
  "node_modules/point-in-polygon/nested.js"(exports, module) {
    module.exports = function pointInPolygonNested(point, vs, start, end) {
      var x = point[0], y = point[1];
      var inside = false;
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = vs.length;
      var len = end - start;
      for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[i + start][0], yi = vs[i + start][1];
        var xj = vs[j + start][0], yj = vs[j + start][1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect)
          inside = !inside;
      }
      return inside;
    };
  }
});

// node_modules/point-in-polygon/index.js
var require_point_in_polygon = __commonJS({
  "node_modules/point-in-polygon/index.js"(exports, module) {
    var pointInPolygonFlat = require_flat();
    var pointInPolygonNested = require_nested();
    module.exports = function pointInPolygon2(point, vs, start, end) {
      if (vs.length > 0 && Array.isArray(vs[0])) {
        return pointInPolygonNested(point, vs, start, end);
      } else {
        return pointInPolygonFlat(point, vs, start, end);
      }
    };
    module.exports.nested = pointInPolygonNested;
    module.exports.flat = pointInPolygonFlat;
  }
});

// node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.esm.js
var React = __toESM(require_react());
var import_react2 = __toESM(require_react());

// node_modules/@floating-ui/react-dom-interactions/node_modules/@floating-ui/core/dist/floating-ui.core.esm.development.js
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (middleware.filter((_ref) => {
      let {
        name
      } = _ref;
      return name === "autoPlacement" || name === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let _debug_loop_count_ = 0;
  for (let i = 0; i < middleware.length; i++) {
    {
      _debug_loop_count_++;
      if (_debug_loop_count_ > 100) {
        throw new Error(["Floating UI: The middleware lifecycle appears to be", "running in an infinite loop. This is usually caused by a `reset`", "continually being returned without a break condition."].join(" "));
      }
    }
    const {
      name,
      fn
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset) {
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x,
      y
    } : rects.reference,
    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      {
        console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min3 = paddingObject[minProp];
    const max3 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min3, center, max3);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
var sides = ["top", "right", "bottom", "left"];
var allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$map$so;
            const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function convertValueToCoords(placement, rects, value, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value({
    ...rects,
    placement
  }) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects,
        platform: platform2,
        elements
      } = middlewareArguments;
      const diffCoords = convertValueToCoords(placement, rects, value, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};

// node_modules/@floating-ui/react-dom-interactions/node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.development.js
function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || // @ts-ignore (TS 4.1 compat)
  css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(
    element,
    // @ts-ignore - checked above (TS 4.1 compat)
    isOffsetParentAnElement && isScaled(offsetParent),
    strategy === "fixed"
  );
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || // DOM Element detected
    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (["html", "body", "#document"].includes(getNodeName(parentNode))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : (
    // @ts-ignore: isBody tells us target will be an HTMLElement here
    updatedList.concat(getOverflowAncestors(target))
  );
}
function contains(parent, child) {
  const rootNode = child == null ? void 0 : child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent != null && parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: {
        ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize: _elementResize = true,
    animationFrame = false
  } = options;
  let cleanedUp = false;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const elementResize = _elementResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    observer = new ResizeObserver(update);
    isElement(reference) && observer.observe(reference);
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    if (cleanedUp) {
      return;
    }
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  return () => {
    var _observer;
    cleanedUp = true;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => computePosition(reference, floating, {
  platform,
  ...options
});

// node_modules/@floating-ui/react-dom-interactions/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var index = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length, i, keys;
  if (a && b && typeof a == "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function useFloating(_temp) {
  let {
    middleware,
    placement = "bottom",
    strategy = "absolute"
  } = _temp === void 0 ? {} : _temp;
  const reference = (0, import_react.useRef)(null);
  const floating = (0, import_react.useRef)(null);
  const [data, setData] = (0, import_react.useState)({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {}
  });
  const [latestMiddleware, setLatestMiddleware] = (0, import_react.useState)(middleware);
  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {
    let {
      options
    } = _ref;
    return options;
  }), middleware == null ? void 0 : middleware.map((_ref2) => {
    let {
      options
    } = _ref2;
    return options;
  }))) {
    setLatestMiddleware(middleware);
  }
  const isMountedRef = (0, import_react.useRef)(true);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const update = (0, import_react.useCallback)(() => {
    if (!reference.current || !floating.current) {
      return;
    }
    computePosition2(reference.current, floating.current, {
      middleware: latestMiddleware,
      placement,
      strategy
    }).then((data2) => {
      if (isMountedRef.current) {
        (0, import_react_dom.flushSync)(() => {
          setData(data2);
        });
      }
    });
  }, [latestMiddleware, placement, strategy]);
  index(update, [update]);
  const setReference = (0, import_react.useCallback)((node) => {
    reference.current = node;
    update();
  }, [update]);
  const setFloating = (0, import_react.useCallback)((node) => {
    floating.current = node;
    update();
  }, [update]);
  const refs = (0, import_react.useMemo)(() => ({
    reference,
    floating
  }), []);
  return (0, import_react.useMemo)(() => ({
    ...data,
    update,
    refs,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, setReference, setFloating]);
}
var arrow2 = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return arrow({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return arrow({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.esm.js
var import_point_in_polygon = __toESM(require_point_in_polygon());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.esm.js
var index2 = typeof document !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      map.set(event, (map.get(event) || []).filter((l) => l !== listener));
    }
  };
}
var serverHandoffComplete = false;
var count = 0;
var genId = () => "floating-ui-" + count++;
function useFloatingId() {
  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
}
var useReactId = React["useId".toString()];
var useId = useReactId != null ? useReactId : useFloatingId;
var FloatingNodeContext = (0, import_react2.createContext)(null);
var FloatingTreeContext = (0, import_react2.createContext)(null);
var useFloatingParentNodeId = () => {
  var _useContext$id, _useContext;
  return (_useContext$id = (_useContext = (0, import_react2.useContext)(FloatingNodeContext)) == null ? void 0 : _useContext.id) != null ? _useContext$id : null;
};
var useFloatingTree = () => (0, import_react2.useContext)(FloatingTreeContext);
function mergeProps(userProps, propsList, elementKey) {
  const fnsMap = {};
  return {
    ...elementKey === "floating" && {
      tabIndex: -1
    },
    ...userProps,
    ...propsList.map((value) => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (key.indexOf("on") === 0) {
          if (!fnsMap[key]) {
            fnsMap[key] = [];
          }
          if (typeof value === "function") {
            fnsMap[key].push(value);
          }
          acc[key] = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            fnsMap[key].forEach((fn) => fn(...args));
          };
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
var useInteractions = function(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  return {
    getReferenceProps: (userProps) => mergeProps(userProps, propsList, "reference"),
    getFloatingProps: (userProps) => mergeProps(userProps, propsList, "floating"),
    getItemProps: (userProps) => mergeProps(userProps, propsList, "item")
  };
};
function getDocument(floating) {
  var _floating$ownerDocume;
  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;
}
function getWindow2(value) {
  var _getDocument$defaultV;
  return (_getDocument$defaultV = getDocument(value).defaultView) != null ? _getDocument$defaultV : window;
}
function isElement2(value) {
  return value ? value instanceof getWindow2(value).Element : false;
}
function isHTMLElement2(value) {
  return value ? value instanceof getWindow2(value).HTMLElement : false;
}
function getChildren(tree, id) {
  var _tree$nodesRef$curren;
  let allChildren = (_tree$nodesRef$curren = tree == null ? void 0 : tree.nodesRef.current.filter((node) => {
    var _node$context;
    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  })) != null ? _tree$nodesRef$curren : [];
  let currentChildren = allChildren;
  while (currentChildren.length) {
    var _tree$nodesRef$curren2;
    currentChildren = (_tree$nodesRef$curren2 = tree == null ? void 0 : tree.nodesRef.current.filter((node) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n2) => {
        var _node$context2;
        return node.parentId === n2.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    })) != null ? _tree$nodesRef$curren2 : [];
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
var DEFAULT_ID = "floating-ui-root";
var FloatingPortal = (_ref) => {
  let {
    children,
    id = DEFAULT_ID
  } = _ref;
  const [mounted, setMounted] = (0, import_react2.useState)(false);
  const portalRef = (0, import_react2.useRef)(null);
  index2(() => {
    const root = document.getElementById(id);
    if (root) {
      portalRef.current = root;
    } else {
      portalRef.current = document.createElement("div");
      portalRef.current.id = id;
    }
    const el = portalRef.current;
    if (!document.body.contains(el)) {
      document.body.appendChild(el);
    }
    setMounted(true);
  }, [id]);
  if (mounted && portalRef.current) {
    return (0, import_react_dom3.createPortal)(children, portalRef.current);
  }
  return null;
};
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var identifier = "data-floating-ui-scroll-lock";
var FloatingOverlay = (0, import_react2.forwardRef)(function FloatingOverlay2(_ref, ref) {
  let {
    lockScroll = false,
    ...rest
  } = _ref;
  index2(() => {
    if (!lockScroll) {
      return;
    }
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const alreadyLocked = document.body.hasAttribute(identifier);
    if (alreadyLocked) {
      return;
    }
    Object.assign(document.body.style, {
      position: "fixed",
      overflow: "hidden",
      top: "-" + scrollY + "px",
      left: "-" + scrollX + "px",
      right: "0",
      [paddingProp]: scrollbarWidth + "px"
    });
    document.body.setAttribute(identifier, "");
    return () => {
      Object.assign(document.body.style, {
        position: "",
        overflow: "",
        top: "",
        left: "",
        right: "",
        [paddingProp]: ""
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return import_react2.default.createElement("div", _extends({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function useLatestRef(value) {
  const ref = (0, import_react2.useRef)(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function focus$1(el) {
  requestAnimationFrame(() => {
    el == null ? void 0 : el.focus();
  });
}
var SELECTOR = "input:not([type='hidden']):not([disabled]),select:not([disabled]),textarea:not([disabled]),a[href],button:not([disabled]),[tabindex],iframe,object,embed,area[href],audio[controls],video[controls],[contenteditable]:not([contenteditable='false'])";
var FocusGuard = (0, import_react2.forwardRef)(function FocusGuard2(props, ref) {
  return import_react2.default.createElement("span", _extends({}, props, {
    ref,
    tabIndex: 0,
    style: {
      position: "fixed",
      opacity: "0",
      pointerEvents: "none",
      outline: "0"
    }
  }));
});
function FloatingFocusManager(_ref) {
  let {
    context: {
      refs,
      nodeId,
      onOpenChange
    },
    children,
    order = ["content"],
    endGuard = true,
    preventTabbing = false,
    initialFocus = 0,
    returnFocus = true,
    modal = true
  } = _ref;
  const orderRef = useLatestRef(order);
  const onOpenChangeRef = useLatestRef(onOpenChange);
  const tree = useFloatingTree();
  const getTabbableElements = (0, import_react2.useCallback)(() => {
    return orderRef.current.map((type) => {
      if (isHTMLElement2(refs.reference.current) && type === "reference") {
        return refs.reference.current;
      }
      if (refs.floating.current && type === "floating") {
        return refs.floating.current;
      }
      if (type === "content") {
        var _refs$floating$curren, _refs$floating$curren2;
        return Array.from((_refs$floating$curren = (_refs$floating$curren2 = refs.floating.current) == null ? void 0 : _refs$floating$curren2.querySelectorAll(SELECTOR)) != null ? _refs$floating$curren : []);
      }
      return null;
    }).flat().filter((el) => {
      if (el === refs.floating.current || el === refs.reference.current) {
        return true;
      }
      if (isHTMLElement2(el)) {
        var _el$getAttribute;
        const tabIndex = (_el$getAttribute = el.getAttribute("tabindex")) != null ? _el$getAttribute : "0";
        return tabIndex[0].trim() !== "-";
      }
    });
  }, [orderRef, refs.floating, refs.reference]);
  (0, import_react2.useEffect)(() => {
    const noTabbableContentElements = getTabbableElements().filter((el) => el !== refs.floating.current && // @ts-expect-error
    el !== refs.reference.current).length === 0;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (preventTabbing || noTabbableContentElements) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        if (orderRef.current[0] === "reference" && event.target === refs.reference.current) {
          stopEvent(event);
          if (event.shiftKey) {
            focus$1(els[els.length - 1]);
          } else {
            focus$1(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && event.target === refs.floating.current && event.shiftKey) {
          stopEvent(event);
          focus$1(els[0]);
        }
      }
    }
    const doc = getDocument(refs.floating.current);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [preventTabbing, getTabbableElements, orderRef, refs.floating, refs.reference]);
  (0, import_react2.useEffect)(() => {
    function onFloatingFocusOut(event) {
      var _refs$floating$curren3;
      const target = event.relatedTarget;
      if (!((_refs$floating$curren3 = refs.floating.current) != null && _refs$floating$curren3.contains(target)) && isElement2(refs.reference.current) && !refs.reference.current.contains(target) && !(tree && getChildren(tree, nodeId).some((child) => {
        var _child$context, _child$context$refs$f;
        return (_child$context = child.context) == null ? void 0 : (_child$context$refs$f = _child$context.refs.floating.current) == null ? void 0 : _child$context$refs$f.contains(target);
      }))) {
        onOpenChangeRef.current(false);
      }
    }
    const floating = refs.floating.current;
    const reference = refs.reference.current;
    if (floating && isHTMLElement2(reference)) {
      !modal && floating.addEventListener("focusout", onFloatingFocusOut);
      const cleanup = modal ? hideOthers(floating) : null;
      return () => {
        !modal && floating.removeEventListener("focusout", onFloatingFocusOut);
        cleanup == null ? void 0 : cleanup();
      };
    }
  }, [nodeId, tree, modal, onOpenChangeRef, getTabbableElements, initialFocus, refs.floating, refs.reference]);
  (0, import_react2.useEffect)(() => {
    var _getDocument$activeEl;
    if (preventTabbing) {
      return;
    }
    const floating = refs.floating.current;
    const previouslyFocusedElement = (_getDocument$activeEl = getDocument(floating).activeElement) != null ? _getDocument$activeEl : document.activeElement;
    if (typeof initialFocus === "number") {
      var _getTabbableElements$;
      focus$1((_getTabbableElements$ = getTabbableElements()[initialFocus]) != null ? _getTabbableElements$ : floating);
    } else if (isHTMLElement2(initialFocus == null ? void 0 : initialFocus.current)) {
      var _initialFocus$current;
      focus$1((_initialFocus$current = initialFocus.current) != null ? _initialFocus$current : floating);
    }
    return () => {
      if (returnFocus && isHTMLElement2(previouslyFocusedElement)) {
        focus$1(previouslyFocusedElement);
      }
    };
  }, [preventTabbing, getTabbableElements, initialFocus, modal, returnFocus, refs.floating]);
  return import_react2.default.createElement(import_react2.default.Fragment, null, modal && import_react2.default.createElement(FocusGuard, {
    onFocus: (event) => {
      stopEvent(event);
      const els = getTabbableElements();
      if (order[0] === "reference") {
        focus$1(els[0]);
      } else {
        focus$1(els[els.length - 1]);
      }
    }
  }), (0, import_react2.cloneElement)(children, order.includes("floating") ? {
    tabIndex: 0
  } : {}), modal && endGuard && import_react2.default.createElement(FocusGuard, {
    onFocus: (event) => {
      stopEvent(event);
      focus$1(getTabbableElements()[0]);
    }
  }));
}
var FloatingDelayGroupContext = (0, import_react2.createContext)({
  delay: 1e3,
  initialDelay: 1e3,
  currentId: null,
  setCurrentId: () => {
  },
  setState: () => {
  }
});
var useRole = function(_ref, _temp) {
  let {
    open
  } = _ref;
  let {
    enabled = true,
    role = "dialog"
  } = _temp === void 0 ? {} : _temp;
  const rootId = useId();
  const referenceId = useId();
  const floatingProps = {
    id: rootId,
    role
  };
  if (!enabled) {
    return {};
  }
  if (role === "tooltip") {
    return {
      reference: {
        "aria-describedby": open ? rootId : void 0
      },
      floating: floatingProps
    };
  }
  return {
    reference: {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": role,
      "aria-controls": open ? rootId : void 0,
      ...role === "listbox" && {
        role: "combobox"
      },
      ...role === "menu" && {
        id: referenceId
      }
    },
    floating: {
      ...floatingProps,
      ...role === "menu" && {
        "aria-labelledby": referenceId
      }
    }
  };
};
var useDismiss = function(_ref, _temp) {
  let {
    open,
    onOpenChange,
    refs,
    events,
    nodeId
  } = _ref;
  let {
    enabled = true,
    escapeKey = true,
    outsidePointerDown = true,
    referencePointerDown = false,
    ancestorScroll = false,
    bubbles = true
  } = _temp === void 0 ? {} : _temp;
  const tree = useFloatingTree();
  const onOpenChangeRef = useLatestRef(onOpenChange);
  const isFocusInsideFloating = (0, import_react2.useCallback)(() => {
    var _refs$floating$curren;
    return (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.contains(getDocument(refs.floating.current).activeElement);
  }, [refs.floating]);
  const focusReference = (0, import_react2.useCallback)(() => {
    if (isHTMLElement2(refs.reference.current)) {
      refs.reference.current.focus();
    }
  }, [refs.reference]);
  (0, import_react2.useEffect)(() => {
    if (!open || !enabled) {
      return;
    }
    function onKeyDown(event) {
      if (event.key === "Escape") {
        if (!bubbles && !isFocusInsideFloating()) {
          return;
        }
        events.emit("dismiss");
        onOpenChangeRef.current(false);
        focusReference();
      }
    }
    function onPointerDown(event) {
      var _refs$floating$curren2;
      const targetIsInsideChildren = tree && getChildren(tree, nodeId).some((node) => {
        var _node$context, _node$context$refs$fl;
        return (_node$context = node.context) == null ? void 0 : (_node$context$refs$fl = _node$context.refs.floating.current) == null ? void 0 : _node$context$refs$fl.contains(event.target);
      });
      if ((_refs$floating$curren2 = refs.floating.current) != null && _refs$floating$curren2.contains(event.target) || isElement2(refs.reference.current) && refs.reference.current.contains(event.target) || targetIsInsideChildren) {
        return;
      }
      if (!bubbles && !isFocusInsideFloating()) {
        return;
      }
      events.emit("dismiss");
      onOpenChangeRef.current(false);
      focusReference();
    }
    function onScroll() {
      onOpenChangeRef.current(false);
    }
    const doc = getDocument(refs.floating.current);
    escapeKey && doc.addEventListener("keydown", onKeyDown);
    outsidePointerDown && doc.addEventListener("mousedown", onPointerDown);
    const ancestors = (ancestorScroll ? [...isElement2(refs.reference.current) ? getOverflowAncestors(refs.reference.current) : [], ...isElement2(refs.floating.current) ? getOverflowAncestors(refs.floating.current) : []] : []).filter((ancestor) => {
      var _doc$defaultView;
      return (
        // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)
        ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport)
      );
    });
    ancestors.forEach((ancestor) => ancestor.addEventListener("scroll", onScroll, {
      passive: true
    }));
    return () => {
      escapeKey && doc.removeEventListener("keydown", onKeyDown);
      outsidePointerDown && doc.removeEventListener("mousedown", onPointerDown);
      ancestors.forEach((ancestor) => ancestor.removeEventListener("scroll", onScroll));
    };
  }, [escapeKey, outsidePointerDown, events, tree, nodeId, open, onOpenChangeRef, focusReference, ancestorScroll, enabled, bubbles, isFocusInsideFloating, refs.floating, refs.reference]);
  if (!enabled) {
    return {};
  }
  return {
    reference: {
      onPointerDown() {
        if (referencePointerDown) {
          events.emit("dismiss");
          onOpenChange(false);
        }
      }
    }
  };
};
function usePrevious(value) {
  const ref = (0, import_react2.useRef)();
  index2(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index3 = startingIndex;
  do {
    var _list$index, _list$index2;
    index3 = index3 + (decrement ? -1 : 1);
  } while (index3 >= 0 && index3 <= list.length - 1 && (list[index3] == null || (_list$index = list[index3]) != null && _list$index.hasAttribute("disabled") || ((_list$index2 = list[index3]) == null ? void 0 : _list$index2.getAttribute("aria-disabled")) === "true"));
  return index3;
}
function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case "vertical":
      return vertical;
    case "horizontal":
      return horizontal;
    default:
      return vertical || horizontal;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToStartKey(key, orientation, rtl) {
  const vertical = key === ARROW_UP;
  const horizontal = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  return doSwitch(orientation, vertical, horizontal);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN;
  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal = key === ARROW_DOWN;
  return doSwitch(orientation, vertical, horizontal);
}
function isCrossOrientationCloseKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal = key === ARROW_UP;
  return doSwitch(orientation, vertical, horizontal);
}
function getMinIndex(listRef) {
  return findNonDisabledIndex(listRef);
}
function getMaxIndex(listRef) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length
  });
}
var useListNavigation = function(_ref, _temp2) {
  let {
    open,
    onOpenChange,
    refs
  } = _ref;
  let {
    listRef,
    activeIndex,
    onNavigate,
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = "auto",
    focusItemOnHover = true,
    orientation = "vertical"
  } = _temp2 === void 0 ? {
    listRef: {
      current: []
    },
    activeIndex: null,
    onNavigate: () => {
    }
  } : _temp2;
  if (true) {
    if (!loop && allowEscape) {
      console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" "));
    }
  }
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  const previousOpen = usePrevious(open);
  const focusOnOpenRef = (0, import_react2.useRef)(focusItemOnOpen);
  const indexRef = (0, import_react2.useRef)(selectedIndex != null ? selectedIndex : -1);
  const keyRef = (0, import_react2.useRef)("");
  const initializedRef = (0, import_react2.useRef)(false);
  const onNavigateRef = useLatestRef(onNavigate);
  const blockPointerLeaveRef = (0, import_react2.useRef)(false);
  const [activeId, setActiveId] = (0, import_react2.useState)();
  const focusItem = (0, import_react2.useCallback)((listRef2, indexRef2) => {
    if (virtual) {
      var _listRef$current$inde;
      setActiveId((_listRef$current$inde = listRef2.current[indexRef2.current]) == null ? void 0 : _listRef$current$inde.id);
    } else {
      var _listRef$current$inde2;
      (_listRef$current$inde2 = listRef2.current[indexRef2.current]) == null ? void 0 : _listRef$current$inde2.focus({
        preventScroll: true
      });
    }
  }, [virtual]);
  index2(() => {
    if (!enabled) {
      return;
    }
    if (selectedIndex != null) {
      indexRef.current = selectedIndex;
    }
    if (!previousOpen && open && focusOnOpenRef.current) {
      onNavigateRef.current(indexRef.current);
      focusItem(listRef, indexRef);
    }
  }, [open, previousOpen, selectedIndex, listRef, onNavigateRef, focusItem, enabled]);
  index2(() => {
    if (!enabled) {
      return;
    }
    if (open) {
      if (activeIndex === null) {
        if (!previousOpen && focusOnOpenRef.current && selectedIndex == null || allowEscape) {
          indexRef.current = allowEscape ? -1 : getMinIndex(listRef);
          onNavigateRef.current(activeIndex);
          focusItem(listRef, indexRef);
        }
      } else {
        indexRef.current = activeIndex;
        onNavigateRef.current(activeIndex);
        focusItem(listRef, indexRef);
      }
    }
  }, [open, previousOpen, activeIndex, selectedIndex, nested, listRef, onNavigateRef, focusItem, enabled, parentId, allowEscape, refs.floating, tree == null ? void 0 : tree.nodesRef]);
  index2(() => {
    if (selectedIndex != null || !enabled) {
      return;
    }
    if (open) {
      if (isMainOrientationKey(keyRef.current, orientation) || focusOnOpenRef.current && (keyRef.current === " " || keyRef.current === "Enter")) {
        const minIndex = getMinIndex(listRef);
        const maxIndex = getMaxIndex(listRef);
        indexRef.current = isMainOrientationToStartKey(keyRef.current, orientation, rtl) ? allowEscape ? listRef.current.length : maxIndex : allowEscape ? -1 : minIndex;
        onNavigateRef.current(indexRef.current);
        focusItem(listRef, indexRef);
      }
    }
    keyRef.current = "";
  }, [open, listRef, selectedIndex, onNavigateRef, focusItem, enabled, orientation, rtl, allowEscape]);
  index2(() => {
    if (!enabled) {
      return;
    }
    if (!open && initializedRef.current && selectedIndex != null && isHTMLElement2(refs.reference.current)) {
      refs.reference.current.focus();
    }
  }, [refs.reference, selectedIndex, open, enabled]);
  index2(() => {
    initializedRef.current = true;
    return () => {
      initializedRef.current = false;
    };
  }, []);
  index2(() => {
    if (!enabled) {
      return;
    }
    if (!open) {
      var _ref2;
      if (focusItemOnOpen === "auto") {
        focusOnOpenRef.current = true;
      }
      indexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;
      onNavigateRef.current(null);
    }
  }, [open, selectedIndex, activeIndex, enabled, focusItemOnOpen, onNavigateRef]);
  function pointerCheck(event) {
    if (focusItemOnOpen === "auto") {
      focusOnOpenRef.current = !event.pointerType;
    }
  }
  function onFloatingKeyDown(event) {
    blockPointerLeaveRef.current = true;
    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
      stopEvent(event);
      onOpenChange(false);
      if (isHTMLElement2(refs.reference.current)) {
        refs.reference.current.focus();
      }
      return;
    }
    const currentIndex = indexRef.current;
    const minIndex = getMinIndex(listRef);
    const maxIndex = getMaxIndex(listRef);
    if (event.key === "Home") {
      indexRef.current = minIndex;
      onNavigate(indexRef.current);
    }
    if (event.key === "End") {
      indexRef.current = maxIndex;
      onNavigate(indexRef.current);
    }
    if (isMainOrientationKey(event.key, orientation)) {
      stopEvent(event);
      if (!virtual && event.currentTarget.ownerDocument.activeElement === event.currentTarget) {
        indexRef.current = selectedIndex != null ? selectedIndex : isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
        onNavigate(indexRef.current);
        return;
      }
      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
        if (loop) {
          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {
            startingIndex: currentIndex
          });
        } else {
          indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {
            startingIndex: currentIndex
          }));
        }
      } else {
        if (loop) {
          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true
          });
        } else {
          indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true
          }));
        }
      }
      onNavigate(indexRef.current);
    }
  }
  if (!enabled) {
    return {};
  }
  return {
    reference: {
      ...virtual && open && activeIndex != null && {
        "aria-activedescendant": activeId
      },
      onPointerEnter: pointerCheck,
      onPointerDown: pointerCheck,
      onKeyDown(event) {
        blockPointerLeaveRef.current = true;
        if (virtual && open) {
          return onFloatingKeyDown(event);
        }
        if (focusItemOnOpen === "auto") {
          focusOnOpenRef.current = true;
        }
        keyRef.current = event.key;
        if (nested) {
          if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {
            stopEvent(event);
            if (open) {
              indexRef.current = getMinIndex(listRef);
              onNavigate(indexRef.current);
            } else {
              onOpenChange(true);
            }
          }
          return;
        }
        if (isMainOrientationKey(event.key, orientation)) {
          if (selectedIndex == null) {
            indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? getMinIndex(listRef) : getMaxIndex(listRef);
          } else {
            indexRef.current = selectedIndex;
          }
          stopEvent(event);
          onOpenChange(true);
          onNavigate(indexRef.current);
        }
        if (virtual && !open) {
          onFloatingKeyDown(event);
        }
      }
    },
    floating: {
      "aria-orientation": orientation === "both" ? void 0 : orientation,
      ...virtual && activeIndex != null && {
        "aria-activedescendant": activeId
      },
      onKeyDown: onFloatingKeyDown,
      onPointerMove() {
        blockPointerLeaveRef.current = false;
      }
    },
    item: {
      onClick: (_ref3) => {
        let {
          currentTarget
        } = _ref3;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      ...focusItemOnHover && {
        onPointerMove(_ref4) {
          let {
            currentTarget
          } = _ref4;
          const target = currentTarget;
          if (target) {
            const index3 = listRef.current.indexOf(target);
            if (index3 !== -1) {
              onNavigate(index3);
            }
          }
        },
        onPointerLeave() {
          if (!blockPointerLeaveRef.current) {
            onNavigate(null);
            if (!virtual) {
              var _refs$floating$curren;
              (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({
                preventScroll: true
              });
            } else {
              indexRef.current = -1;
              focusItem(listRef, indexRef);
            }
          }
        }
      }
    }
  };
};
function useFloating2(_temp) {
  let {
    open = false,
    onOpenChange = () => {
    },
    placement,
    middleware,
    strategy,
    nodeId
  } = _temp === void 0 ? {} : _temp;
  const tree = useFloatingTree();
  const dataRef = (0, import_react2.useRef)({});
  const events = (0, import_react2.useState)(() => createPubSub())[0];
  const floating = useFloating({
    placement,
    middleware,
    strategy
  });
  const context = (0, import_react2.useMemo)(() => ({
    ...floating,
    dataRef,
    nodeId,
    events,
    open,
    onOpenChange
  }), [floating, dataRef, nodeId, events, open, onOpenChange]);
  index2(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return (0, import_react2.useMemo)(() => ({
    context,
    ...floating
  }), [floating, context]);
}

// node_modules/htm/react/index.module.js
var import_react3 = __toESM(require_react());

// node_modules/htm/dist/htm.module.js
var n = function(t2, s, r2, e) {
  var u;
  s[0] = 0;
  for (var h = 1; h < s.length; h++) {
    var p = s[h++], a = s[h] ? (s[0] |= p ? 1 : 2, r2[s[h++]]) : s[++h];
    3 === p ? e[0] = a : 4 === p ? e[1] = Object.assign(e[1] || {}, a) : 5 === p ? (e[1] = e[1] || {})[s[++h]] = a : 6 === p ? e[1][s[++h]] += a + "" : p ? (u = t2.apply(a, n(t2, a, r2, ["", null])), e.push(u), a[0] ? s[0] |= 2 : (s[h - 2] = 0, s[h] = u)) : e.push(a);
  }
  return e;
};
var t = /* @__PURE__ */ new Map();
function htm_module_default(s) {
  var r2 = t.get(this);
  return r2 || (r2 = /* @__PURE__ */ new Map(), t.set(this, r2)), (r2 = n(this, r2.get(s) || (r2.set(s, r2 = function(n2) {
    for (var t2, s2, r3 = 1, e = "", u = "", h = [0], p = function(n3) {
      1 === r3 && (n3 || (e = e.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h.push(0, n3, e) : 3 === r3 && (n3 || e) ? (h.push(3, n3, e), r3 = 2) : 2 === r3 && "..." === e && n3 ? h.push(4, n3, 0) : 2 === r3 && e && !n3 ? h.push(5, 0, true, e) : r3 >= 5 && ((e || !n3 && 5 === r3) && (h.push(r3, 0, e, s2), r3 = 6), n3 && (h.push(r3, n3, 0, s2), r3 = 6)), e = "";
    }, a = 0; a < n2.length; a++) {
      a && (1 === r3 && p(), p(a));
      for (var l = 0; l < n2[a].length; l++)
        t2 = n2[a][l], 1 === r3 ? "<" === t2 ? (p(), h = [h], r3 = 3) : e += t2 : 4 === r3 ? "--" === e && ">" === t2 ? (r3 = 1, e = "") : e = t2 + e[0] : u ? t2 === u ? u = "" : e += t2 : '"' === t2 || "'" === t2 ? u = t2 : ">" === t2 ? (p(), r3 = 1) : r3 && ("=" === t2 ? (r3 = 5, s2 = e, e = "") : "/" === t2 && (r3 < 5 || ">" === n2[a][l + 1]) ? (p(), 3 === r3 && (h = h[0]), r3 = h, (h = h[0]).push(2, 0, r3), r3 = 0) : " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2 ? (p(), r3 = 2) : e += t2), 3 === r3 && "!--" === e && (r3 = 4, h = h[0]);
    }
    return p(), h;
  }(s)), r2), arguments, [])).length > 1 ? r2 : r2[0];
}

// node_modules/htm/react/index.module.js
var o = htm_module_default.bind(import_react3.createElement);

// node_modules/click-to-react-component/src/ClickToComponent.js
var React3 = __toESM(require_react(), 1);

// node_modules/click-to-react-component/src/ContextMenu.js
var React2 = __toESM(require_react(), 1);

// node_modules/react-merge-refs/dist/react-merge-refs.esm.js
function mergeRefs(refs) {
  return function(value) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var react_merge_refs_esm_default = mergeRefs;

// node_modules/click-to-react-component/src/getDisplayNameFromReactInstance.js
function getDisplayNameForInstance(instance) {
  const { elementType, tag } = instance;
  switch (tag) {
    case 0:
    case 1:
      return elementType.displayName || elementType.name || "Anonymous Component";
    case 5:
      return elementType;
    case 6:
      return "String";
    case 7:
      return "React.Fragment";
    case 9:
      return "Context.Consumer";
    case 10:
      return "Context.Provider";
    case 11:
      return "React.forwardRef";
    case 15:
      return elementType.type.name || "React.memo";
    case 16:
      return "React.lazy";
    default:
      console.warn(`Unrecognized React Fiber tag: ${tag}`, instance);
      return "Unknown Component";
  }
}

// node_modules/click-to-react-component/src/getPathToSource.js
function getPathToSource(source, pathModifier) {
  const {
    // It _does_ exist!
    // @ts-ignore Property 'columnNumber' does not exist on type 'Source'.ts(2339)
    columnNumber = 1,
    fileName,
    lineNumber = 1
  } = source;
  let path = `${fileName}:${lineNumber}:${columnNumber}`;
  if (pathModifier) {
    path = pathModifier(path);
  }
  return path;
}

// node_modules/click-to-react-component/src/getPropsForInstance.js
function getPropsForInstance(instance) {
  const props = {};
  Object.entries(instance.memoizedProps).forEach(([key, value]) => {
    var _a;
    const type = typeof value;
    if (["key"].includes(key) || value === ((_a = instance.type.defaultProps) == null ? void 0 : _a[key])) {
      return;
    }
    if (["string", "number", "boolean", "symbol"].includes(type) || value instanceof String || value instanceof Number || value instanceof Boolean || value instanceof Symbol) {
      props[key] = value;
    }
  });
  return props;
}

// node_modules/click-to-react-component/src/getReactInstanceForElement.js
function getReactInstanceForElement(element) {
  if ("__REACT_DEVTOOLS_GLOBAL_HOOK__" in window) {
    const { renderers } = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    for (const renderer of renderers.values()) {
      try {
        const fiber = renderer.findFiberByHostInstance(element);
        if (fiber) {
          return fiber;
        }
      } catch (e) {
      }
    }
  }
  if ("_reactRootContainer" in element) {
    return element._reactRootContainer._internalRoot.current.child;
  }
  for (const key in element) {
    if (key.startsWith("__reactInternalInstance$")) {
      return element[key];
    }
    if (key.startsWith("__reactFiber")) {
      return element[key];
    }
  }
}

// node_modules/click-to-react-component/src/getReactInstancesForElement.js
function getReactInstancesForElement(element) {
  const instances = /* @__PURE__ */ new Set();
  let instance = getReactInstanceForElement(element);
  while (instance) {
    instances.add(instance);
    instance = instance._debugOwner;
  }
  return Array.from(instances);
}

// node_modules/click-to-react-component/src/getSourceForInstance.js
function getSourceForInstance({ _debugSource, _debugOwner }) {
  const source = _debugSource || _debugOwner && _debugOwner._debugSource;
  if (!source)
    return;
  const {
    // It _does_ exist!
    // @ts-ignore Property 'columnNumber' does not exist on type 'Source'.ts(2339)
    columnNumber = 1,
    fileName,
    lineNumber = 1
  } = source;
  return { columnNumber, fileName, lineNumber };
}

// node_modules/click-to-react-component/src/ContextMenu.js
var ContextMenu = React2.forwardRef(
  (props, ref) => {
    const { onClose, pathModifier } = props;
    const [target, setTarget] = React2.useState(
      /** @type {HTMLElement | null} */
      null
    );
    const arrowRef = React2.useRef(
      /** @type {HTMLElement | null} */
      null
    );
    const [activeIndex, setActiveIndex] = React2.useState(
      /** @type {number | null} */
      null
    );
    const [open, setOpen] = React2.useState(false);
    const listItemsRef = React2.useRef(
      /** @type {Array<HTMLButtonElement | null>} */
      []
    );
    const {
      x,
      y,
      reference,
      floating,
      strategy,
      refs,
      update,
      context,
      placement,
      middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }
    } = useFloating2({
      open,
      onOpenChange(open2) {
        setOpen(open2);
        if (!open2)
          onClose == null ? void 0 : onClose();
      },
      middleware: [
        offset({ mainAxis: 5, alignmentAxis: 4 }),
        flip(),
        shift(),
        arrow2({ element: arrowRef })
      ],
      placement: "right"
    });
    const { getFloatingProps, getItemProps } = useInteractions([
      useRole(context, { role: "menu" }),
      useDismiss(context),
      useListNavigation(context, {
        listRef: listItemsRef,
        activeIndex,
        onNavigate: setActiveIndex,
        focusItemOnOpen: false
      })
    ]);
    React2.useEffect(() => {
      if (open && refs.reference.current && refs.floating.current) {
        return autoUpdate(refs.reference.current, refs.floating.current, update);
      }
    }, [open, update, refs.reference, refs.floating]);
    const mergedReferenceRef = React2.useMemo(
      () => react_merge_refs_esm_default([ref, reference]),
      [reference, ref]
    );
    React2.useEffect(() => {
      function onContextMenu(e) {
        if (!e.altKey) {
          return;
        }
        e.preventDefault();
        mergedReferenceRef({
          getBoundingClientRect() {
            return {
              x: e.clientX,
              y: e.clientY,
              width: 0,
              height: 0,
              top: e.clientY,
              right: e.clientX,
              bottom: e.clientY,
              left: e.clientX
            };
          }
        });
        setOpen(true);
        if (e.target instanceof HTMLElement)
          setTarget(e.target);
      }
      document.addEventListener("contextmenu", onContextMenu);
      return () => {
        document.removeEventListener("contextmenu", onContextMenu);
      };
    }, [mergedReferenceRef]);
    React2.useLayoutEffect(() => {
      var _a;
      if (open) {
        (_a = refs.floating.current) == null ? void 0 : _a.focus();
      }
    }, [open, refs.floating]);
    React2.useLayoutEffect(() => {
      if (!arrowRef.current)
        return;
      const staticSide = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
      }[placement.split("-")[0]];
      Object.assign(arrowRef.current.style, {
        display: "block",
        left: arrowX != null ? `${arrowX}px` : "",
        top: arrowY != null ? `${arrowY}px` : "",
        right: "",
        bottom: "",
        [staticSide]: "-4px"
      });
    }, [arrowX, arrowY, placement]);
    if (!target) {
      return null;
    }
    const instances = getReactInstancesForElement(target).filter(
      (instance) => getSourceForInstance(instance)
    );
    return o`
      <style key="click-to-component-contextmenu-style">
        #floating-ui-root > div {
          z-index: 2147483647;
        }

        [data-click-to-component-contextmenu],
        [data-click-to-component-contextmenu] * {
          box-sizing: border-box !important;
        }

        [data-click-to-component-contextmenu] {
          all: unset;
          outline: 0;
          background: white;
          color: black;
          font-weight: bold;
          overflow: visible;
          padding: 5px;
          font-size: 13px;
          border-radius: 6px;
          border: none;

          --shadow-color: 0deg 0% 0%;
          --shadow-elevation-low: 0px -1px 0.8px hsl(var(--shadow-color) / 0.1),
            0px -1.2px 0.9px -2.5px hsl(var(--shadow-color) / 0.07),
            0px -3px 2.3px -5px hsl(var(--shadow-color) / 0.03);

          --shadow-elevation-medium: 0px 1px 0.8px
              hsl(var(--shadow-color) / 0.11),
            0px 1.5px 1.1px -1.7px hsl(var(--shadow-color) / 0.08),
            0px 5.1px 3.8px -3.3px hsl(var(--shadow-color) / 0.05),
            0px 15px 11.3px -5px hsl(var(--shadow-color) / 0.03);
          --shadow-elevation-high: 0px 1px 0.8px hsl(var(--shadow-color) / 0.1),
            0px 1.1px 0.8px -0.7px hsl(var(--shadow-color) / 0.09),
            0px 2.1px 1.6px -1.4px hsl(var(--shadow-color) / 0.07),
            0px 4.9px 3.7px -2.1px hsl(var(--shadow-color) / 0.06),
            0px 10.1px 7.6px -2.9px hsl(var(--shadow-color) / 0.05),
            0px 18.9px 14.2px -3.6px hsl(var(--shadow-color) / 0.04),
            0px 31.9px 23.9px -4.3px hsl(var(--shadow-color) / 0.02),
            0px 50px 37.5px -5px hsl(var(--shadow-color) / 0.01);

          box-shadow: var(--shadow-elevation-high);
          filter: drop-shadow(0px 0px 0.5px rgba(0 0 0 / 50%));
        }

        [data-click-to-component-contextmenu] button {
          all: unset;
          outline: 0;
          display: flex;
          flex-direction: column;
          width: 100%;
          padding: 5px;
          border-radius: 4px;
          font-size: 13px;
        }

        [data-click-to-component-contextmenu] button:focus,
        [data-click-to-component-contextmenu] button:not([disabled]):active {
          cursor: pointer;
          background: royalblue;
          color: white;
          box-shadow: var(--shadow-elevation-medium);
        }

        [data-click-to-component-contextmenu] button:focus code,
        [data-click-to-component-contextmenu]
          button:not([disabled]):active
          code {
          color: white;
        }

        [data-click-to-component-contextmenu] button > * + * {
          margin-top: 3px;
        }

        [data-click-to-component-contextmenu] button code {
          color: royalblue;
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
            'Liberation Mono', 'Courier New', monospace;
        }

        [data-click-to-component-contextmenu] button code var {
          background: rgba(0 0 0 / 5%);
          cursor: help;
          border-radius: 3px;
          padding: 3px 6px;
          font-style: normal;
          font-weight: normal;
          font-family: ui-sans-serif, system-ui, -apple-system,
            BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
            'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
            'Segoe UI Symbol', 'Noto Color Emoji';
        }

        [data-click-to-component-contextmenu] button cite {
          font-weight: normal;
          font-style: normal;
          font-size: 11px;
          opacity: 0.5;
          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
            'Liberation Mono', 'Courier New', monospace;
        }

        [data-click-to-component-contextmenu] button cite data::after {
          content: attr(value);
          float: right;
          padding-left: 15px;
          font-family: ui-sans-serif, system-ui, -apple-system,
            BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
            'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
            'Segoe UI Symbol', 'Noto Color Emoji';
        }

        [data-click-to-component-contextmenu-arrow] {
          display: none;
          position: absolute;
          background: inherit;
          width: 8px;
          height: 8px;
          transform: rotate(45deg);
        }
      </style>

      ${open && o`
        <${FloatingOverlay} key="click-to-component-overlay" lockScroll>
          <${FloatingFocusManager} context=${context}>
            <dialog
              ...${getFloatingProps({
      ref: floating,
      style: {
        position: strategy,
        top: y ?? "",
        left: x ?? ""
      }
    })}
              data-click-to-component-contextmenu
              onClose=${function handleClose(event) {
      onClose(refs.floating.current.returnValue);
      setOpen(false);
    }}
              open
            >
              <form method="dialog">
                ${instances.map((instance, i) => {
      const name = getDisplayNameForInstance(instance);
      const source = getSourceForInstance(instance);
      const path = getPathToSource(source, pathModifier);
      const props2 = getPropsForInstance(instance);
      return o`
                    <button
                      ...${getItemProps({
        role: "menuitem",
        ref(node) {
          listItemsRef.current[i] = node;
        }
      })}
                      key=${i}
                      name="path"
                      type="submit"
                      value=${path}
                    >
                      <code>
                        ${"<"}${name}
                        ${Object.entries(props2).map(
        ([prop, value]) => o`
                            ${" "}
                            <var key=${prop} title="${value}">${prop}</var>
                          `
      )}
                        ${">"}
                      </code>
                      <cite>
                        <data
                          value="${source.lineNumber}:${source.columnNumber}"
                        >
                          ${source.fileName.replace(/.*(src|pages)/, "$1")}
                        </data>
                      </cite>
                    </button>
                  `;
    })}
              </form>

              <div
                data-click-to-component-contextmenu-arrow
                ref=${arrowRef}
              />
            </dialog>
          </${FloatingFocusManager}>
        </${FloatingOverlay}>
      `}
    `;
  }
);

// node_modules/click-to-react-component/src/getSourceForElement.js
function getSourceForElement(element) {
  const instance = getReactInstanceForElement(element);
  const source = getSourceForInstance(instance);
  if (source)
    return source;
  console.warn("Couldn't find a React instance for the element", element);
}

// node_modules/click-to-react-component/src/getUrl.js
function getUrl({ editor, pathToSource }) {
  if (pathToSource[0] === "/") {
    return `${editor}://file${pathToSource}`;
  }
  return `${editor}://file/${pathToSource}`;
}

// node_modules/click-to-react-component/src/ClickToComponent.js
var State = (
  /** @type {const} */
  {
    IDLE: "IDLE",
    HOVER: "HOVER",
    SELECT: "SELECT"
  }
);
function ClickToComponent({ editor = "vscode", pathModifier }) {
  const [state, setState] = React3.useState(
    /** @type {State[keyof State]} */
    State.IDLE
  );
  const [target, setTarget] = React3.useState(
    /** @type {HTMLElement | null} */
    null
  );
  const onClick = React3.useCallback(
    function handleClick(event) {
      if (state === State.HOVER && target instanceof HTMLElement) {
        const source = getSourceForElement(target);
        const path = getPathToSource(source, pathModifier);
        const url = getUrl({
          editor,
          pathToSource: path
        });
        event.preventDefault();
        window.location.assign(url);
        setState(State.IDLE);
      }
    },
    [editor, state, target]
  );
  const onClose = React3.useCallback(
    function handleClose(returnValue) {
      if (returnValue) {
        const url = getUrl({
          editor,
          pathToSource: returnValue
        });
        window.location.assign(url);
      }
      setState(State.IDLE);
    },
    [editor]
  );
  const onContextMenu = React3.useCallback(
    function handleContextMenu(event) {
      const { target: target2 } = event;
      if (state === State.HOVER && target2 instanceof HTMLElement) {
        event.preventDefault();
        setState(State.SELECT);
        setTarget(target2);
      }
    },
    [state]
  );
  const onKeyDown = React3.useCallback(
    function handleKeyDown(event) {
      switch (state) {
        case State.IDLE:
          if (event.altKey)
            setState(State.HOVER);
          break;
        default:
      }
    },
    [state]
  );
  const onKeyUp = React3.useCallback(
    function handleKeyUp(event) {
      switch (state) {
        case State.HOVER:
          setState(State.IDLE);
          break;
        default:
      }
    },
    [state]
  );
  const onMouseMove = React3.useCallback(
    function handleMouseMove(event) {
      if (!(event.target instanceof HTMLElement)) {
        return;
      }
      switch (state) {
        case State.IDLE:
        case State.HOVER:
          setTarget(event.target);
          break;
        default:
          break;
      }
    },
    [state]
  );
  const onBlur = React3.useCallback(
    function handleBlur() {
      switch (state) {
        case State.HOVER:
          setState(State.IDLE);
          break;
        default:
      }
    },
    [state]
  );
  React3.useEffect(
    function toggleIndicator() {
      for (const element of Array.from(
        document.querySelectorAll("[data-click-to-component-target]")
      )) {
        if (element instanceof HTMLElement) {
          delete element.dataset.clickToComponentTarget;
        }
      }
      if (state === State.IDLE) {
        delete window.document.body.dataset.clickToComponent;
        if (target) {
          delete target.dataset.clickToComponentTarget;
        }
        return;
      }
      if (target instanceof HTMLElement) {
        window.document.body.dataset.clickToComponent = state;
        target.dataset.clickToComponentTarget = state;
      }
    },
    [state, target]
  );
  React3.useEffect(
    function addEventListenersToWindow() {
      window.addEventListener("click", onClick, { capture: true });
      window.addEventListener("contextmenu", onContextMenu, { capture: true });
      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("keyup", onKeyUp);
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("blur", onBlur);
      return function removeEventListenersFromWindow() {
        window.removeEventListener("click", onClick, { capture: true });
        window.removeEventListener("contextmenu", onContextMenu, {
          capture: true
        });
        window.removeEventListener("keydown", onKeyDown);
        window.removeEventListener("keyup", onKeyUp);
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("blur", onBlur);
      };
    },
    [onClick, onContextMenu, onKeyDown, onKeyUp, onMouseMove, onBlur]
  );
  return o`
    <style key="click-to-component-style">
      [data-click-to-component] * {
        pointer-events: auto !important;
      }

      [data-click-to-component-target] {
        cursor: var(--click-to-component-cursor, context-menu) !important;
        outline: auto 1px;
        outline: var(
          --click-to-component-outline,
          -webkit-focus-ring-color auto 1px
        ) !important;
      }
    </style>

    <${FloatingPortal} key="click-to-component-portal">
      ${o`<${ContextMenu}
        key="click-to-component-contextmenu"
        onClose=${onClose}
        pathModifier=${pathModifier}
      />`}
    </${FloatingPortal}
  `;
}

// node_modules/click-to-react-component/src/index.js
var ClickToComponent2 = true ? ClickToComponent : () => null;
export {
  ClickToComponent2 as ClickToComponent
};
//# sourceMappingURL=click-to-react-component.js.map
